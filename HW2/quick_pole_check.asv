% File: hw2_pole_check_from_den.m
% Purpose: Compute poles from the transfer-function denominator and
%          cross-check with the A-matrix eigenvalues.

clear; clc;

%% Motor params (rated flux)
R = 1.43;              % [ohm]
L = 2.38e-3;           % [H]
K = 0.0991;            % [N·m/A] = [V·s/rad]
J = 5.508e-5;          % [kg·m^2]  (converted from 0.0078 oz·in·s^2)
B = 0;                 % [N·m·s/rad]  (set >0 if you want to test damping)

%% Denominator of G(s) = omega(s)/V(s)
% General coupled PMDC (open-loop) has:
%   s^2 + (R/L + B/J) s + (RB/(LJ) + K^2/(LJ))
a2 = 1;
a1 = R/L + B/J;
a0 = (R*B)/(L*J) + (K^2)/(L*J);
den = [a2 a1 a0];

% Poles from the TF denominator (roots)
p_tf = roots(den);

% Cross-check: eigenvalues of the state matrix
A = [-R/L, -K/L;
      K/J, -B/J];
p_eig = eig(A);

%% Report
fprintf('Denominator coefficients: [1  %.6f  %.6f]\n', a1, a0);
fprintf('Poles from TF denominator (roots):   %10.4f  %10.4f  [1/s]\n', p_tf);
fprintf('Poles from state matrix (eig(A)):     %10.4f  %10.4f  [1/s]\n', p_eig);

% Optional: show time constants and damping ratio (for intuition)
tau_a = L/R;                     % electrical time constant
tau_m = (J*R)/(K^2);             % electromechanical time constant (B=0 case)
zeta  = (a1)/(2*sqrt(a0));       % damping ratio of the 2nd-order denominator
wn    = sqrt(a0);                % natural frequency

fprintf('\nTau_a = %.4e s,  Tau_m = %.4e s,  zeta = %.3f,  wn = %.1f rad/s\n', ...
        tau_a, tau_m, zeta, wn);
%% ================== Part 2(c): K = 300% of nominal ==================
K3 = 3*K;                     % 300% flux => K scaled by 3

% Denominator of G(s) = ω(s)/V(s) with possible viscous B
a2_3 = 1;
a1_3 = R/L + B/J;
a0_3 = (R*B)/(L*J) + (K3^2)/(L*J);
den3 = [a2_3 a1_3 a0_3];

% Poles from TF denominator and from A-matrix
p_tf_3  = roots(den3);
A3      = [-R/L, -K3/L;
            K3/J, -B/J];
p_eig_3 = eig(A3);

% Damping ratio and natural frequency (2nd-order denominator)
wn3   = sqrt(a0_3);
zeta3 = a1_3/(2*wn3);

fprintf('\n=== Part 2(c): Poles with K = 300%% of nominal (K = %.4f) ===\n', K3);
fprintf('Denominator: s^2 + (%.6f)s + (%.6f)\n', a1_3, a0_3);
fprintf('Poles from TF denominator (roots):   %10.4f %10.4f [1/s]\n', p_tf_3);
fprintf('Poles from state matrix (eig(A)):     %10.4f %10.4f [1/s]\n', p_eig_3);
fprintf('wn = %.2f rad/s,  zeta = %.3f  => %s\n', wn3, zeta3, ...
    ternary(zeta3<1,'UNDERDAMPED (oscillatory)','NON-oscillatory'));

% --- tiny local helper for printing ---
function out = ternary(cond, a, b)
    if cond, out = a; else, out = b; end
end